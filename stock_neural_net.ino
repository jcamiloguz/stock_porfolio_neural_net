/******************************************************************
 * Programa que genera una onda senoidal usando una red neuronal
 * MLP superficial
 ******************************************************************/

#include <math.h>

/******************************************************************
 * Definición estructura de la red
 ******************************************************************/

const int HiddenNodes1 = 8;
const int HiddenNodes2 = 8;
const int HiddenNodes3 = 8;
const int InputNodes = 6;
const int OutputNodes = 1;

const float HiddenWeights1[HiddenNodes1][InputNodes+1]= {
  {0.326062,-0.35083967,0.28867468,-0.06090508,0.5870413,-0.7514238,-0.01154604},
  {0.46264768,-0.35270336,0.71168005,0.4520024,-0.23970503,0.05609331,-0.0594109},
  {0.2272323,0.559015,0.37797788,0.9010427,-0.066842,0.46833572,-0.08984739},
  {0.17055249,0.4009319,-0.11527409,-0.78001046,0.01600814,-0.25964034,0.08854797},
  {-0.5539943,0.26855466,-0.58636236,0.38474602,0.39279312,0.49152857,0.04357992},
  {0.6813174,-0.2931423,0.16452871,-0.3094454,-0.00391781,0.35319537,0.00864475},
  {-0.7422053,0.07422647,-0.47973007,-0.34635884,0.58896667,-0.26382536,0.032609},
  {-0.5406209,0.43452224,-0.7410007,0.49928135,0.24321352,0.1695275,0.04020784}
    }; 
const float HiddenWeights2[HiddenNodes2][HiddenNodes1+1]= {
  {-0.17531703, 0.29517624,-0.23422198,0.12376001,0.09341605,0.1164333,-0.48269132,0.16079058,-0.00504777},
{0.6984924,0.35627106,0.387834,-0.01913145,-0.91909117,0.45495844,-0.6824593,-0.40861815,-0.02565508},
{0.0479399,-0.9580184,0.04655476,-0.03773121,0.5957882,0.18423007,0.4449994,0.701263,-0.09325965},
{-0.5869185,0.19314033,0.10855418,-0.29286495,-0.44972956,-0.57909214,-0.48558885,-0.13768226,0},
{-0.00619513,0.5170012,-0.00354594,-0.39993024,-0.5633722,-0.45613843,-0.08424985,0.27135873,0},
{0.41236585,-0.1830579,0.01204199,-0.41673028,-0.47882012,-0.20414206,0.42346066,-0.1533984,0},
{-0.3831776,-0.2602585,0.8581953,-0.8855081,0.6456449,-0.7703042,-0.01567639,0.8014331,-0.09656413},
{-0.3822195,-0.10591546,0.6231169,-0.503379,-0.03988186,-0.4692617,0.2989386,0.23384203,0.01712312}
    };  
const float HiddenWeights3[HiddenNodes3][HiddenNodes2+1]= {
 {0.35765895,-0.51349247,0.5694581,0.2582534,0.5957596,0.42157108,-0.6943109,-0.4536287,-0.04696986},
{-0.54509044,-0.0936644,0.39680585,-0.38748324,0.22811413,0.49194223,-0.39946875,0.5386178,-0.04406738},
{-0.22366446,-0.57055444,0.65423614,-0.23332256,-0.49028498,-0.5297552,-0.8000024,0.28379953,-0.04271107},
{-0.03729446,0.2958429,0.6912571,-0.26746735,-0.5612692,0.29002947,-0.63529825,-0.53626525,-0.03971995},
{0.4609348,-0.09519044,0.05323736,0.46426445,-0.0092293,0.06870574,-0.58573544,0.59294033,-0.00132869},
{-0.33675778,-0.7352587,0.15492722,0.45173413,-0.317401,-0.35070047,-0.12779583,-0.2679891,-0.05275408},
{-0.3948518,0.3709878,-0.14190948,-0.48794562,0.43354064,0.56850487,0.1974414,0.29570377,0.02138823},
{0.03370102,0.9856108,-0.5312118,0.50557774,-0.2713977,0.331865,1.0666218,0.19360352,0.07551563}
    }; 


// Pesos capa de salida
const float OutputWeights[OutputNodes][HiddenNodes3+1]  = {
{ -0.8730964 ,
 -0.6736472 ,
 -0.8655035 ,
 -0.63692164,
 -0.23599714,
 -0.7931799 ,
  0.37925324,
  1.4309452 ,0.07752119}
    }; 


int i, j, p, q, r;
float Accum;
float Hidden1[HiddenNodes1];
float Hidden2[HiddenNodes2];
float Hidden3[HiddenNodes3];
float Output[OutputNodes];
float Input[InputNodes];
const float Entrada[13][6] ={
  {0.25, 0.  , 0.25, 0.25, 0.25, 0.  },
       {0.  , 0.25, 0.25, 0.25, 0.25, 0.  },
       {0.25, 0.25, 0.25, 0.  , 0.  , 0.25},
       {0.25, 0.25, 0.  , 0.25, 0.  , 0.25},
       {0.25, 0.  , 0.25, 0.25, 0.  , 0.25},
       {0.  , 0.25, 0.25, 0.25, 0.  , 0.25},
       {0.25, 0.25, 0.  , 0.  , 0.25, 0.25},
       {0.25, 0.  , 0.25, 0.  , 0.25, 0.25},
       {0.  , 0.25, 0.25, 0.  , 0.25, 0.25},
       {0.25, 0.  , 0.  , 0.25, 0.25, 0.25},
       {0.  , 0.25, 0.  , 0.25, 0.25, 0.25},
       {0.  , 0.  , 0.25, 0.25, 0.25, 0.25},
       {0.2 , 0.2 , 0.2 , 0.2 , 0.2 , 0.  }
       }
 

void setup(){
  //start serial connection
  Serial.begin(9600);
}


void loop(){


Input[0]=Entrada;

/******************************************************************
* Cálculo de la salida de 1era capa oculta
******************************************************************/

    for( i = 0 ; i < HiddenNodes1 ; i++ ) {    
      Accum = HiddenWeights1[i][InputNodes] ;
      for( j = 0 ; j < InputNodes ; j++ ) {
        Accum += HiddenWeights1[i][j]*Input[j];
      }
        Hidden1[i] = 1 / (1 + exp(-Accum));
    }

   /******************************************************************
* Cálculo de la salida de 2da capa oculta
******************************************************************/ 
    for( i = 0 ; i < HiddenNodes2 ; i++ ) {    
      Accum = HiddenWeights2[i][InputNodes] ;
      for( j = 0 ; j < HiddenNodes1 ; j++ ) {
        Accum += HiddenWeights2[i][j]*Hidden1[j];
      }
        Hidden2[i] = (Accum>0)?Accum:0;
    }
   /******************************************************************
* Cálculo de la salida de 3ra capa oculta
******************************************************************/ 
    for( i = 0 ; i < HiddenNodes3 ; i++ ) {    
      Accum = HiddenWeights3[i][InputNodes] ;
      for( j = 0 ; j < HiddenNodes2 ; j++ ) {
        Accum += HiddenWeights3[i][j]*Hidden2[j];
      }
        Hidden3[i] =Accum
    }

/******************************************************************
* Cálculo de la salida de capa de salida
******************************************************************/
    for( i = 0 ; i < OutputNodes ; i++ ) {    
      Accum = OutputWeights[i][HiddenNodes3] ;
      for( j = 0 ; j < HiddenNodes3 ; j++ ) {
        Accum +=  OutputWeights[i][j]*Hidden3[j];
      }
        Output[i] = 1 / (1 + exp(-Accum)); 

    }

Salida=Output[0];


Serial.print("Salida Des: "); 
Serial.println( Salida);      

delay(500);  

}
